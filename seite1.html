					<div id="mw-content-text" class="mw-body-content"><div class="mw-content-ltr mw-parser-output" lang="de" dir="ltr"><p>Die <b>objektorientierte Programmierung</b> (kurz <b>OOP</b>) ist ein auf dem Konzept der <a href="/wiki/Objektorientierung" title="Objektorientierung">Objektorientierung</a> basierendes <a href="/wiki/Programmierparadigma" title="Programmierparadigma">Programmierparadigma</a>. Die Grundidee besteht darin, die <a href="/wiki/Softwarearchitektur" title="Softwarearchitektur">Architektur</a> einer Software an den <a href="/wiki/Ontologie" title="Ontologie">Grundstrukturen</a> desjenigen Bereichs der Wirklichkeit auszurichten, der die gegebene Anwendung betrifft. Ein Modell dieser Strukturen wird in der <a href="/wiki/Softwaredesign" title="Softwaredesign">Entwurfsphase</a> aufgestellt. Es enthält Informationen über die auftretenden Objekte und deren Abstraktionen, ihre <a href="/wiki/Abstrakter_Datentyp" title="Abstrakter Datentyp">Typen</a>. Die Umsetzung dieser Denkweise erfordert die Einführung verschiedener Konzepte, insbesondere <a href="/wiki/Klasse_(Objektorientierung)" title="Klasse (Objektorientierung)">Klassen</a>, <a href="/wiki/Vererbung_(Programmierung)" title="Vererbung (Programmierung)">Vererbung</a>, <a href="/wiki/Polymorphie_(Programmierung)" title="Polymorphie (Programmierung)">Polymorphie</a> und spätes Binden (<a href="/wiki/Dynamisches_Binden" class="mw-redirect" title="Dynamisches Binden">dynamisches Binden</a>).
<p>Die Definition, was <i>objektorientierte Programmierung</i> ist und im Kern ausmacht, variiert und ist auch Veränderungen unterworfen.
</p><p><a href="/wiki/Alan_Kay" title="Alan Kay">Alan Kay</a>, der Erfinder der Programmiersprache <a href="/wiki/Smalltalk_(Programmiersprache)" title="Smalltalk (Programmiersprache)">Smalltalk</a> und des Begriffs „object oriented“, definierte ihn im Kontext von Smalltalk folgendermaßen:
<p>“1. Everything is an object, 2.&nbsp;Objects communicate by sending and receiving messages (in terms of objects), 3.&nbsp;Objects have their own memory (in terms of objects), 4.&nbsp;Every object is an instance of a class (which must be an object), 5.&nbsp;The class holds the shared behavior for its instances (in the form of objects in a program list), 6.&nbsp;To eval a program list, control is passed to the first object and the remainder is treated as its message”
<p>„1. Alles ist ein Objekt, 2.&nbsp;Objekte kommunizieren durch das Senden und Empfangen von Nachrichten (welche aus Objekten bestehen), 3.&nbsp;Objekte haben ihren eigenen Speicher (strukturiert als Objekte), 4.&nbsp;Jedes Objekt ist die Instanz einer Klasse (welche ein Objekt sein muss), 5.&nbsp;Die Klasse beinhaltet das Verhalten aller ihrer Instanzen (in der Form von Objekten in einer Programmliste), 6.&nbsp;Um eine Programmliste auszuführen, wird die Ausführungskontrolle dem ersten Objekt gegeben und das Verbleibende als dessen Nachricht behandelt“
<p>Alan Kay drückte später seine Unzufriedenheit über den von ihm gewählten Begriff „Objektorientierung“ aus, weil dieser aus seiner Sicht den Kernaspekt des <i>Messaging</i> zu kurz kommen ließe.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span class="cite-bracket">[</span>2<span class="cite-bracket">]</span></a></sup>
</p><p>2003 gab Alan Kay folgende Definition von objektorientierter Programmierung:
<p>“OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things.”
<p>„OOP bedeutet für mich nur Messaging, lokales Beibehalten und Schützen und Verbergen des Prozesszustands sowie <a href="/wiki/Dynamische_Bindung" title="Dynamische Bindung">spätestmögliche Bindung</a> aller Dinge.“
<p>Der <a href="/wiki/Internationale_Organisation_f%C3%BCr_Normung" title="Internationale Organisation für Normung">ISO/IEC-2382-15</a>-Standard von 1999 definiert den Begriff <i>object-oriented</i> dagegen wie folgt:
<p>“Pertaining to a technique or a programming language that supports objects, classes, and inheritance.”
<p>„Bezieht sich auf eine Technik oder Programmiersprache, welche Objekte, Klassen und Vererbung unterstützt.“
<p>Die ISO-Definition gilt inzwischen im Allgemeinen als zu vereinfachend, da auch klassenlose objektorientierte Sprachen existieren und auch der Vererbung inzwischen weniger Bedeutung beigemessen wird als noch in den 1990ern.
<p>Im Vergleich mit anderen Programmiermethoden verwendet die objektorientierte Programmierung neue, andere Begriffe.
</p><p>Die einzelnen Bausteine, aus denen ein objektorientiertes Programm während seiner Abarbeitung besteht, werden als Objekte bezeichnet. Die Objekte werden dabei in der Regel auf Basis der folgenden Konzepte entwickelt:
<p>Zur besseren Verwaltung gleichartiger Objekte bedienen sich die meisten Programmiersprachen des Konzeptes der Klasse. Klassen sind Vorlagen, aus denen Instanzen genannte Objekte zur Laufzeit erzeugt werden. Im Programm werden nicht einzelne Objekte, sondern eine Klasse gleichartiger Objekte definiert. Existieren in der gewählten Programmiersprache keine Klassen oder werden diese explizit unterdrückt, so spricht man zur Unterscheidung oft auch von <a href="/wiki/Objektbasierte_Programmierung" title="Objektbasierte Programmierung">objektbasierter Programmierung</a>.
</p><p>Man kann sich die Erzeugung von Objekten aus einer Klasse vorstellen wie das Fertigen von Autos aus dem Konstruktionsplan eines bestimmten Fahrzeugtyps. Klassen sind die Konstruktionspläne für Objekte.
</p><p>Die Klasse entspricht in etwa einem komplexen <a href="/wiki/Datentyp" title="Datentyp">Datentyp</a> wie in der <a href="/wiki/Prozedurale_Programmierung" title="Prozedurale Programmierung">prozeduralen Programmierung</a>, geht aber darüber hinaus: Sie legt nicht nur die Datentypen fest, aus denen die mit Hilfe der Klassen erzeugten Objekte bestehen, sie definiert zudem die <a href="/wiki/Algorithmus" title="Algorithmus">Algorithmen</a>, die auf diesen Daten operieren. Während also zur Laufzeit eines Programms einzelne Objekte miteinander interagieren, wird das Grundmuster dieser Interaktion durch die Definition der einzelnen Klassen festgelegt.
</p><p><b>Beispiel</b>
</p><p>Die Klasse „Auto“ legt fest, dass das Auto vier Reifen einer bestimmten Größe, fünf farbige Türen, einen Motor mit einer bestimmten Leistung und fünf Sitze mit wählbaren Bezügen hat.
<p>Es handelt sich um drei Objekte; zwei davon haben gleiche Attribute. Alle drei sind aber Ausprägungen (Instanzen) der Klasse „Auto“.
<p>Die einer Klasse von Objekten zugeordneten Algorithmen bezeichnet man auch als <a href="/wiki/Methode_(Programmierung)" title="Methode (Programmierung)">Methoden</a>.
</p><p>Häufig wird der Begriff <i>Methode</i> synonym zu den Begriffen <a href="/wiki/Funktion_(Programmierung)" title="Funktion (Programmierung)">Funktion</a> oder <a href="/wiki/Prozedur_(Programmierung)" title="Prozedur (Programmierung)">Prozedur</a> aus anderen Programmiersprachen gebraucht. Die Funktion oder Prozedur ist jedoch eher als Implementierung einer Methode zu betrachten. Im täglichen Sprachgebrauch sagt man auch „Objekt&nbsp;<i>A</i> ruft Methode&nbsp;<i>m</i> von Objekt&nbsp;<i>B</i> auf.“
</p><p>Eine besondere Rolle spielen Methoden für die <a href="/wiki/Datenkapselung_(Programmierung)" title="Datenkapselung (Programmierung)">Kapselung</a>, insbesondere die <a href="/wiki/Zugriffsfunktion" title="Zugriffsfunktion">Zugriffsfunktionen</a>. Spezielle Methoden zur Erzeugung und <i>Zerstörung</i> von Objekten heißen <a href="/wiki/Konstruktoren_und_Destruktoren" title="Konstruktoren und Destruktoren">Konstruktoren beziehungsweise Destruktoren</a>.
</p><p>Methoden können <a href="/wiki/Parameter_(Informatik)" title="Parameter (Informatik)">Parameter</a> erhalten, die beim Aufruf übergeben werden müssen, und einen Rückgabewert besitzen, den sie am Ende dem Aufrufer zurückgeben. Beispielsweise hat die Methode <i>addiere</i> die Parameter <i>Zahl 1</i> und <i>Zahl 2</i> und gibt als Rückgabewert die Summe der Zahlen zurück.
</p><p>In vielen objektorientierten Programmiersprachen lässt sich festlegen, welche Objekte eine bestimmte Methode aufrufen dürfen. So wird meist zwischen folgenden vier Zugriffsebenen unterschieden, die bereits zur <a href="/wiki/Kompilierung" class="mw-redirect" title="Kompilierung">Übersetzungszeit</a> geprüft werden.
<p>Analog zu diesen vier Zugriffsebenen sind in der <a href="/wiki/Unified_Modeling_Language" title="Unified Modeling Language">Unified Modeling Language</a> (UML) vier <a href="/wiki/Sichtbarkeit_(Programmierung)" title="Sichtbarkeit (Programmierung)">Sichtbarkeiten</a> für <a href="/wiki/Operation_(UML)" title="Operation (UML)">Operationen</a> definiert.
<p>Objekte (Fenster, Schaltflächen, Laufleisten, Menüs,&nbsp;…) besitzen verschiedene Eigenschaften (Farbe, Größe, Ausrichtung,&nbsp;…). Diese Eigenschaften eines Objekts heißen <i>Attribute</i>.
<p>Unter bestimmten Voraussetzungen können Algorithmen, die auf den Schnittstellen eines bestimmten Objekttyps operieren, auch mit Objekten davon abgeleiteter Klassen zusammenarbeiten.
</p><p>Geschieht dies so, dass durch Vererbung überschriebene Methoden an Stelle der Methoden der vererbenden Klasse ausgeführt werden, dann spricht man von Polymorphie. Polymorphie stellt damit eine Möglichkeit dar, einer durch ähnliche Objekte ausgeführten Aktion einen Namen zu geben, wobei jede Klasse die Aktion in einer für das Objekt geeigneten Weise implementiert.
</p><p>Diese Technik, das sogenannte <i>Overriding</i>, implementiert aber keine universelle <a href="/wiki/Polymorphie_(Programmierung)" title="Polymorphie (Programmierung)">Polymorphie</a>, sondern nur die sogenannte Ad-hoc-Polymorphie.
<p>Die Begriffe der objektorientierten Programmierung haben teilweise unterschiedliche Namen. Folgende Bezeichnungen werden synonym verwendet:
<p>Objektorientierte <a href="/wiki/Programmiersprache" title="Programmiersprache">Programmiersprachen</a> unterstützen die Programmstrukturierung mit einem speziellen <a href="/wiki/Datentyp" title="Datentyp">Datentyp</a> – dem <a href="/wiki/Objekt_(Programmierung)" title="Objekt (Programmierung)">Objekt</a>, der die Objektorientierung ermöglicht. Die <i>rein</i> objektorientierten Sprachen, wie <a href="/wiki/Smalltalk_(Programmiersprache)" title="Smalltalk (Programmiersprache)">Smalltalk</a>, folgen dem Prinzip: „Alles ist ein Objekt.“ Auch elementare Typen wie <a href="/wiki/Integer_(Datentyp)" title="Integer (Datentyp)">Ganzzahlen</a> werden dabei durch Objekte repräsentiert – selbst Klassen sind hier Objekte, die wiederum Exemplare von Metaklassen sind. Die verbreiteten objektorientierten Programmiersprachen, unter anderem <a href="/wiki/C-Sharp" title="C-Sharp">C#</a>, <a href="/wiki/C%2B%2B" title="C++">C++</a> und <a href="/wiki/Java_(Programmiersprache)" title="Java (Programmiersprache)">Java</a>, handhaben das Objektprinzip nicht alle so streng. Bei ihnen sind elementare Datentypen keine vollwertigen Objekte, da sie auf Methoden und Struktur verzichten müssen. Sie stellen dem Entwickler auch frei, wie stark er die <a href="/wiki/Datenkapselung_(Programmierung)" title="Datenkapselung (Programmierung)">Kapselung</a> objektinterner Daten einhält.
</p><p>Die erste bekannte objektorientierte Programmiersprache war <a href="/wiki/Simula" title="Simula">Simula</a>-67. Später wurden die Prinzipien der Kapselung in einer Klassenhierarchie dann in <a href="/wiki/Smalltalk_(Programmiersprache)" title="Smalltalk (Programmiersprache)">Smalltalk</a> weiter ausgebaut. Mit dem <a href="/wiki/ANSI" class="mw-redirect" title="ANSI">ANSI</a>/X3.226-1994-Standard wurde <a href="/wiki/Common_Lisp" title="Common Lisp">Common Lisp</a>/<a href="/wiki/Common_Lisp_Object_System" title="Common Lisp Object System">CLOS</a> zur ersten standardisierten objektorientierten Programmiersprache und mit <a href="/wiki/International_Organization_for_Standardization" class="mw-redirect" title="International Organization for Standardization">ISO</a> 8652:1995 wurde <a href="/wiki/Ada_(Programmiersprache)" title="Ada (Programmiersprache)">Ada 95</a> als erste nach dem internationalen ISO-Standard normierte objektorientierte Programmiersprache festgelegt.
</p><p>Gängige moderne Programmiersprachen (z.&nbsp;B. <a href="/wiki/Python_(Programmiersprache)" title="Python (Programmiersprache)">Python</a>) unterstützen sowohl die OOP als auch den prozeduralen Ansatz, der in den <a href="/wiki/Prozedurale_Programmierung" title="Prozedurale Programmierung">klassischen Programmiersprachen</a> der 1970er- und 1980er-Jahre wie <a href="/wiki/Pascal_(Programmiersprache)" title="Pascal (Programmiersprache)">Pascal</a>, <a href="/wiki/Fortran" title="Fortran">Fortran</a> oder <a href="/wiki/C_(Programmiersprache)" title="C (Programmiersprache)">C</a> vorherrschte. Im Gegensatz dazu setzt Smalltalk, die älteste heute noch bedeutsame OOP-Sprache, auf kompromisslose Objektorientierung und hatte damit starken Einfluss auf die Entwicklung populärer OOP-Sprachen, ohne selber deren Verbreitung zu erreichen, weil keine kostengünstig allgemein verfügbare Implementierung angeboten wurde. Auch wenn der Durchbruch der OOP erst in den 1990er-Jahren stattfand, wurde die objektorientierte Programmierung bereits Ende der 1960er Jahre mit Simula-67 als Lösungsansatz für die Modularisierung und die Wiederverwendbarkeit von Code entwickelt.
<p>In einigen objektorientierten Programmiersprachen wie <a href="/wiki/Go_(Programmiersprache)" title="Go (Programmiersprache)">Go</a>, <a href="/wiki/NewtonScript" title="NewtonScript">NewtonScript</a> und <a href="/wiki/Self_(Programmiersprache)" title="Self (Programmiersprache)">Self</a> wird auf die Deklaration von Klassen gänzlich verzichtet. Stattdessen werden neue Objekte von bestehenden Objekten, den sogenannten <a href="/wiki/Prototypenbasierte_Programmierung" title="Prototypenbasierte Programmierung">Prototypen</a>, abgeleitet. Die Attribute und Methoden des Prototyps kommen immer dann zum Einsatz, wenn sie im abgeleiteten Objekt nicht explizit überschrieben wurden. Dies ist vor allem für die Entwicklung kleinerer Programme von Vorteil, da es einfacher und zeitsparend ist.
</p><p>In manchen Programmiersprachen, beispielsweise in <a href="/wiki/Objective-C" title="Objective-C">Objective-C</a>, gibt es zu jeder Klasse ein bestimmtes Objekt (<a href="/w/index.php?title=Klassenobjekt&amp;action=edit&amp;redlink=1" class="new" title="Klassenobjekt (Seite nicht vorhanden)">Klassenobjekt</a>), das die Klasse zur Laufzeit repräsentiert; dieses Klassenobjekt ist dann auch für die Erzeugung von Objekten der Klasse und den Aufruf der korrekten Methode zuständig.
</p><p>Klassen werden in der Regel in Form von <a href="/wiki/Klassenbibliothek" class="mw-redirect" title="Klassenbibliothek">Klassenbibliotheken</a> zusammengefasst, die häufig thematisch organisiert sind. So können Anwender einer objektorientierten Programmiersprache Klassenbibliotheken erwerben, die zum Beispiel den Zugriff auf Datenbanken ermöglichen.
<p>Die Wortarten einer sprachlichen Problembeschreibung können hilfreiche Hinweise dafür geben, eine Objekt-basierte Modellierung zu konzipieren (sogenannte <i>Verb-Substantiv-Methode</i>).<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span class="cite-bracket">[</span>6<span class="cite-bracket">]</span></a></sup> Dabei werden Objekte und Klassen in der Regel sprachlich durch <a href="/wiki/Substantiv" title="Substantiv">Substantive</a> beschrieben, wobei Eigennamen auf Objekte und <a href="/wiki/Appellativ" class="mw-redirect" title="Appellativ">Appellative</a> wie <i>Haus</i> und <i>Tier</i> auf Klassen hindeuten.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span class="cite-bracket">[</span>7<span class="cite-bracket">]</span></a></sup> <a href="/wiki/Verb" title="Verb">Verben</a> stehen in der Regel für Methoden, wobei <a href="/wiki/Adverb" title="Adverb">Adverbien</a> und Substantive ergänzende Charakterisierungen der Methoden geben können. Die Werte von Objektattributen entsprechen häufig <a href="/wiki/Numeral" class="mw-redirect" title="Numeral">Numeralien</a> oder <a href="/wiki/Adjektiv" title="Adjektiv">Adjektiven</a>.<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span class="cite-bracket">[</span>8<span class="cite-bracket">]</span></a></sup>
</p><p>Es gibt inzwischen auch Verfeinerungen der objektorientierten Programmierung durch Methoden wie <a href="/wiki/Entwurfsmuster" title="Entwurfsmuster">Entwurfsmuster</a>, <a href="/wiki/Design_by_contract" class="mw-redirect" title="Design by contract">Design by contract</a> und grafische <a href="/wiki/Modellierungssprache" title="Modellierungssprache">Modellierungssprachen</a> wie die <a href="/wiki/Unified_Modeling_Language" title="Unified Modeling Language">Unified Modeling Language</a>.
</p><p>Einen immer höheren Stellenwert nimmt die <a href="/wiki/Aspektorientierte_Programmierung" title="Aspektorientierte Programmierung">aspektorientierte Programmierung</a> ein, bei der Aspekte von Eigenschaften und Abhängigkeiten beschrieben werden. Erste Ansätze sind beispielsweise in Java mit <a href="/wiki/Jakarta_EE" title="Jakarta EE">Jakarta EE</a> oder der abstrakten Datenhaltung über Persistenzschichten sichtbar.
<p>Das objektorientierte Paradigma hat Vor- und Nachteile je nach Anwendungsfeld in der Softwaretechnik oder konkreter Problemstellung.
<p>Die OOP kann, wie auch andere Programmierparadigmen, verwendet werden, Probleme aus der realen Welt abzubilden. Als ein typisches Beispiel für Problemstellungen, die sich einer geschickten Modellierung mit OOP-Techniken entziehen, gilt das <a href="/wiki/Kreis-Ellipse-Problem" title="Kreis-Ellipse-Problem">Kreis-Ellipse-Problem</a>.
<p>Objektorientierte Programmiersprachen können auch unter sprachwissenschaftlichen Aspekten mit natürlichen Sprachen verglichen werden. OO-Programmiersprachen haben ihren Fokus auf den Objekten, welche sprachlich <a href="/wiki/Substantiv" title="Substantiv">Substantive</a> sind. Die <a href="/wiki/Verb" title="Verb">Verben</a> (<i>Aktionen</i>) sind sekundär, fest an Substantive gebunden (<i>gekapselt</i>) und können im Allgemeinen nicht für sich allein stehen. Bei natürlichen Sprachen und z.&nbsp;B. prozeduralen Sprachen existieren Verben eigenständig und unabhängig von den Substantiven (Daten), z.&nbsp;B. als Imperativ und <a href="/wiki/Funktion_(Programmierung)" title="Funktion (Programmierung)">Funktion</a>. Es kann argumentiert werden, dass diese sprachliche Einschränkung in einigen Anwendungsfällen zu unnötig komplizierten Beschreibungen von Problemen aus der realen Welt mit objektorientierten Sprachen führt.<sup id="cite_ref-executioniKoN_9-0" class="reference"><a href="#cite_note-executioniKoN-9"><span class="cite-bracket">[</span>9<span class="cite-bracket">]</span></a></sup><sup id="cite_ref-executioniKoN2_10-0" class="reference"><a href="#cite_note-executioniKoN2-10"><span class="cite-bracket">[</span>10<span class="cite-bracket">]</span></a></sup>
<p>Häufig genannte Vorzüge des OOP-Paradigmas sind eine verbesserte <a href="/wiki/Wartbarkeit" title="Wartbarkeit">Wartbarkeit</a> und <a href="/wiki/Wiederverwendbarkeit" title="Wiederverwendbarkeit">Wiederverwendbarkeit</a> des statischen Quellcodes.<sup id="cite_ref-realisticcodereuse_11-0" class="reference"><a href="#cite_note-realisticcodereuse-11"><span class="cite-bracket">[</span>11<span class="cite-bracket">]</span></a></sup> Hierzu werden jedoch die Kontrollflüsse und das dynamische Laufzeitverhalten den Daten/Objekten im Allgemeinen untergeordnet, abstrahiert und weggekapselt. Die <a href="/wiki/Kontrollfluss" title="Kontrollfluss">Kontrollflüsse</a> bilden sich nicht mehr für den Entwickler transparent direkt in den Codestrukturen ab (wie z.&nbsp;B. bei <a href="/wiki/Prozedurale_Programmierung" title="Prozedurale Programmierung">prozeduralen Sprachen</a>), eine Umsetzung in dieser Hinsicht wird dem <a href="/wiki/Compiler" title="Compiler">Compiler</a> überlassen. Hardware-nähere Sprachen wie das prozedurale <a href="/wiki/C_(Programmiersprache)" title="C (Programmiersprache)">C</a> oder <a href="/wiki/Assemblersprache" title="Assemblersprache">Assembler</a> bilden den echten Kontrollfluss und das Laufzeitverhalten transparenter ab.<sup id="cite_ref-flaws_12-0" class="reference"><a href="#cite_note-flaws-12"><span class="cite-bracket">[</span>12<span class="cite-bracket">]</span></a></sup> Mit der wachsenden Bedeutung von paralleler Hardware und <a href="/wiki/Parallele_Programmierung" title="Parallele Programmierung">nebenläufigem Code</a> wird jedoch eine bessere Kontrolle und Entwickler-Transparenz der komplexer werdenden Kontrollflüsse immer wichtiger – etwas, das schwierig mit OOP zu erreichen ist.<sup id="cite_ref-multithreadingisaverb_13-0" class="reference"><a href="#cite_note-multithreadingisaverb-13"><span class="cite-bracket">[</span>13<span class="cite-bracket">]</span></a></sup><sup id="cite_ref-multicore_14-0" class="reference"><a href="#cite_note-multicore-14"><span class="cite-bracket">[</span>14<span class="cite-bracket">]</span></a></sup>
<p>Ein häufig genannter Bereich, in dem OOP-Techniken als unzureichend gelten, ist die Anbindung von <a href="/wiki/Relationale_Datenbank" title="Relationale Datenbank">relationalen Datenbanken</a>. OOP-Objekte lassen sich nicht direkt in allen Aspekten mit relationalen Datenbanken abbilden. Umgekehrt können über OOP die Stärken und Fähigkeiten von relationalen Datenbanken ebenfalls nicht vollständig ausgeschöpft werden. Die Notwendigkeit, eine Brücke zwischen diesen beiden Konzeptwelten zu schlagen, ist als <a href="/wiki/Object-relational_impedance_mismatch" title="Object-relational impedance mismatch">object-relational impedance mismatch</a> bekannt. Hierzu existieren viele Ansätze, beispielsweise die häufig verwendete <a href="/wiki/Objektrelationale_Abbildung" title="Objektrelationale Abbildung">objektrelationale Abbildung</a>, jedoch keine allgemeingültige Lösung ohne den einen oder anderen Nachteil.<sup id="cite_ref-RDMDBobjectmis_15-0" class="reference"><a href="#cite_note-RDMDBobjectmis-15"><span class="cite-bracket">[</span>15<span class="cite-bracket">]</span></a></sup>
<p>Die Effektivität des Laufzeitverhaltens von Anwendungen, die auf OOP-Techniken basieren, wird seit jeher kontrovers diskutiert. Alexander Chatzigeorgiou von der <a href="/wiki/Universit%C3%A4t_Makedonien" title="Universität Makedonien">Universität Makedonien</a> verglich die Laufzeiteffektivität und die Energieeffizienz von typischen Algorithmen (<a href="/wiki/Gau%C3%9F-Jordan-Algorithmus" title="Gauß-Jordan-Algorithmus">Gauß-Jordan-Algorithmus</a>, <a href="/wiki/Trapez-Integration" class="mw-redirect" title="Trapez-Integration">Trapez-Integration</a> und <a href="/wiki/Quicksort" title="Quicksort">QuickSort</a>) von <a href="/wiki/Prozedurale_Programmierung" title="Prozedurale Programmierung">prozeduralen Ansätzen</a> und OOP-Techniken, implementiert als C- und C++-Software. Auf dem verwendeten <a href="/wiki/Arm-Architektur" class="mw-redirect" title="Arm-Architektur">ARM-Prozessor</a> ergab sich für drei Algorithmen im Mittel eine um 48,41&nbsp;% bessere Laufzeiteffektivität mit den prozeduralen C-Algorithmusvarianten. Es ergab sich außerdem eine im Mittel um 95,34&nbsp;% höhere Leistungsaufnahme der C++-Varianten zu den C-Varianten.<sup id="cite_ref-chatz_16-0" class="reference"><a href="#cite_note-chatz-16"><span class="cite-bracket">[</span>16<span class="cite-bracket">]</span></a></sup> Für Anwendungen auf mobilen Geräten, wie Handys oder MP3-Spielern mit begrenzten Leistungs- und Energiespeichervermögen, sind derartige Unterschiede signifikant, allerdings machen derartige Algorithmen in der Regel nur einen Bruchteil der Applikationen aus.
<p>Luca Cardelli untersuchte 1996 für das <a href="/wiki/Digital_Equipment_Corporation" title="Digital Equipment Corporation">DEC</a> Systems Research Center die Effizienz von OOP-Ansätzen in dem Artikel <i>Bad Engineering Properties of Object-Oriented Languages</i> mit den Metriken Programmablaufgeschwindigkeit (<i>economy of execution</i>), Kompilationsgeschwindigkeit (<i>economy of compilation</i>), Entwicklungseffizienz für große und kleine Teams (<i>economy of small-scale development</i> und <i>economy of large-scale development</i>) und die Eleganz des Sprachumfangs selbst (<i>economy of language features</i>). Er kam zu dem Schluss, dass das objektorientierte Sprachdesign noch viel aus dem prozeduralen Sprachendesign lernen müsste, insbesondere im Bereich der guten Modularisierung, der Datenabstraktion und des Polymorphismus, um die hochgesteckten Erwartungen zu erfüllen.<sup id="cite_ref-badproperties_17-0" class="reference"><a href="#cite_note-badproperties-17"><span class="cite-bracket">[</span>17<span class="cite-bracket">]</span></a></sup>
<p>Eine Studie von Potok et&nbsp;al. aus dem Jahre 1999 zeigte keine signifikanten Produktivitätsunterschiede zwischen OOP und prozeduralen Ansätzen.<sup id="cite_ref-potok_18-0" class="reference"><a href="#cite_note-potok-18"><span class="cite-bracket">[</span>18<span class="cite-bracket">]</span></a></sup>
</p><p>Die Autoren definieren „Produktivität“ in der Einheit „entwickelte/geänderte <a href="/wiki/Lines_of_Code" title="Lines of Code">Programmzeilen</a> pro Zeiteinheit“ und untersuchen insbesondere den Einfluss von <a href="/wiki/Wiederverwendbarkeit" title="Wiederverwendbarkeit">Code Reuse</a> auf diese Metrik. Sie weisen darauf hin, dass eine Konzentration auf Code Reuse unter Umständen der objektorientierten Programmierung nicht gerecht wird, da sie sich noch auf andere Weisen positiv auf die Produktivität auswirken könnte (beispielsweise durch ein einfacheres Design).
</p><p>Die Autoren führen mehrere Gründe an, weshalb die Ergebnisse ihrer Studie verzerrt sein könnten:
<p>Die Autoren vertreten die Meinung, diese Punkte träfen nicht zu.
<p><br>
<p>Der Text ist unter der Lizenz <a rel="nofollow" class="external text" href="https://creativecommons.org/licenses/by-sa/4.0/deed.de">„Creative-Commons Namensnennung – Weitergabe unter gleichen Bedingungen“</a> verfügbar; Informationen zu den Urhebern und zum Lizenzstatus eingebundener Mediendateien (etwa Bilder oder Videos) können im Regelfall durch Anklicken dieser abgerufen werden. Möglicherweise unterliegen die Inhalte jeweils zusätzlichen Bedingungen. Durch die Nutzung dieser Website erklären Sie sich mit den <span class="plainlinks"><a class="external text" href="https://foundation.wikimedia.org/wiki/Policy:Terms_of_Use/de">Nutzungsbedingungen</a> und der <a class="external text" href="https://foundation.wikimedia.org/wiki/Policy:Privacy_policy/de">Datenschutzrichtlinie</a></span> einverstanden.<br />
